这篇文档将介绍如何使用云渲染SDK实现一些特定场景功能。

# 如何给云端程序发送交互事件?
## 1.基础按键事件
云渲染SDK提供了基础的交互事件类，客户端可以通过```TcrSession#getKeyboard()、TcrSession#getMouse()、TcrSession#getGamepad()、TcrSession#getTouchScreen()```等接口获取```Keyboard、Mouse、Gamepad、TouchScreen```等对象，给云端程序发送键盘、鼠标、手柄、触摸等事件。
客户端可以根据自己的需要使用不同的方式给云端发送事件，例如既可以通过监听设备插入的物理键盘给云端程序发送键盘事件，也可以通过显示在屏幕上的软键盘UI给云端程序发送键盘事件。
## 2.屏幕触摸转鼠标操作
由于大部分客户端需要在触摸屏上给云端程序发送触摸或鼠标事件，因此我们提供了```PcTouchListener/MobileTouchListener```两个工具方便客户端快速接入。
客户端只需要创建这两个类的实例，并且通过```TcrRenderView#setOnTouchListener()```设置给渲染视图，渲染视图上的触摸事件会自动转换为相应输入并发送到云端。
### MobileTouchListener: 
监听```View.OnTouchListenero#nTouch(View, MotionEvent)```的触摸事件，并通过```TouchScreen```对象将触摸事件发送到云端。
### PcTouchListener: 
监听```View.OnTouchListenero#nTouch(View, MotionEvent)```的触摸事件，并通过```Mouse```对象将鼠标操作事件发送到云端，支持以下操作:
- 单指移动: 触摸屏幕移动手指时触发鼠标移动事件
- 单指短按: 默认实现是PcClickListener，可以通过```PcTouchListener#setShortClickListener()```定制短按事件
- 单指长按: 默认实现是PcClickListener，可以通过```PcTouchListener#setLongClickListener()```定制长按事件
其中, ```PcClickListener```的默认行为是通过Mouse发送鼠标的点击事件，可通过```PcClickListener#setMouseKey()```选择鼠标点击的是左键还是右键。
- 单指双击: 可以通过```PcTouchListener#setDoubleClickListener()```定制单指双击事件，默认无任何操作。
- 双指操作: ```PcTouchListener```支持双指缩放或移动渲染视图```TcrRenderView```，客户端可以通过```PcTouchListener#setZoomHandler()```定制双指操作
其中, ```ZoomListener#setZoomListener()```支持监听缩放系数以及缩放中心点。

# 开启终端超分辨率
超分辨率(Super-Resolution)即通过硬件或软件的方法提高原有图像的分辨率，通过一系列低分辨率的图像来得到一幅高分辨率的图像过程就是超分辨率重建。

云渲染SDK实现了终端本地的超分辨率技术，可以在终端渲染云端画面时，增强画质。让用户在相同的传输分辨率和码率下提升体验，在低码率网络下体验到高码率的画面效果。但是，超分辨率算法会使用大量的GPU资源，带来一定的耗电量增加和发热，同时在性能较差的手机上也导致渲染帧率降低。所以，是否要开启，建议App将此功能做成动态开关，由用户决定。

调用方法 
通过```TcrRenderView tcrRenderView = TcrSdk.getInstance().createTcrRenderView(context, TcrSession, TcrRenderViewType.SURFACE);```拿到TcrRenderView对象后，即可调用```tcrRenderView.enableSuperResolution(true)```开启超分能力。  
在TcrRenderView对象未被释放之前，可以随时开启和关闭超分。超分接口最低支持Android 5.0 (API级别21)。

# 外接鼠标键盘设备
TcrSdk已支持 手机/电视/电视盒子外接输入设备使用，可将外接设备的输入传递到云端电脑上进行处理。该功能默认开启，您可以通过TcrRenderView#setEnableInputDeviceHandle来关闭该功能。

如果你想要隐藏掉sdk绘制的默认白色鼠标，可以通过PcTouchListener#setMouseConfig(isRelativeMove,moveSensitivity,cursorVisibility)的改变cursorVisibility值为false来隐藏。

如果你想要隐藏掉android系统绘制的光标，可以通过在添加TcrRenderView到视图上之后调用``` TcrRenderView.requestPointerCapture();```来实现(API级别26)。

# 拉起客户端键盘
客户端可以使用Keyboard相关接口，实现本地键盘UI，让用户通过键盘UI向云端发送按键。为了在用户点击输入框时自动拉起本地键盘UI，可以监听```TcrSession.Event()```接口的```INPUT_STATE_CHANGE```消息，以获取云端输入框状态，并实现自动拉起本地键盘UI的功能。

# 本地输入法
在云端为Android应用的场景下，客户端可能希望直接将文本信息发送到云端，而不使用云端默认的软键盘。
首先，可以使用```TcrSession.setDisableCloudInput()```关闭云端输入法，然后通过监听```TcrSession.Event()```接口的```INPUT_STATE_CHANGE```消息获取云端输入框状态。一旦拉起本地输入框，可以通过调用```TcrSession.pasteText()```接口一次性发送文本内容。

# 手游的横竖屏处理
当云端应用是Android移动应用时，云端程序可能会触发横竖屏切换，客户端需要同步横竖屏状态，以便和云端保持同步。
并且由于视频流画面(采集)方向是固定的，可能会和横竖屏状态不同，因此客户端还需要根据视频流和和横竖屏状态对本地视频画面做一个旋转处理。

## 1.同步横竖屏状态
客户端可以监听```TcrSession.Event()```接口的```SCREEN_CONFIG_CHANGE```消息, 该消息下发的数据```ScreenConfig```中orientation表示云端横竖屏状态。
即客户端收到SCREEN_CONFIG_CHANGE消息时可以如下更新客户端本地的横竖屏状态:
```
    /**
     * 旋转屏幕方向, 以便本地的屏幕方向和云端保持一致<br>
     * 注意: 请确保Manifest中的Activity有android:configChanges="orientation|screenSize"配置, 避免Activity因旋转而被销毁.<br>
     **/
    @SuppressLint("SourceLockedOrientationActivity")
    private void updateOrientation() {
        Log.i(TAG, "updateOrientation:" + mScreenConfig.orientation);
        if (mScreenConfig.orientation.equals("portrait")) {
            setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
        } else if (mScreenConfig.orientation.equals("landscape")) {
            setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
        }
        mScreenConfigChanged = true;
    }
```
## 2.旋转视频画面
由于视频流画面方向可能会和应用方向不一致，因此客户端还需要根据视频流和屏幕方向对画面做一个旋转处理。
客户端可以监听```TcrSession.Event()```接口的```VIDEO_STREAM_CONFIG_CHANGED```消息, 该消息下发的数据```VideoStreamConfig```表示视频流分辨率的宽高。
```
    /**
     * 根据云端屏幕配置旋转视频画面
     */
    private void updateRotation() {
    	// 仅在云端发生了横竖屏旋转且获得视频流配置时才进行画面旋转
        if (!mScreenConfigChanged || !mVideoStreamConfigChanged) {
            Log.w(TAG, "updateRotation failed,mScreenConfigChanged=" + mScreenConfigChanged
                    + "  mVideoStreamConfigChanged=" + mScreenConfigChanged);
            return;
        }
        if (mVideoStreamConfig.width > mVideoStreamConfig.height) {
            if (mScreenConfig.orientation.equals("portrait")) {
                mRenderView.setVideoRotation(VideoRotation.ROTATION_90);
            } else {
                mRenderView.setVideoRotation(VideoRotation.ROTATION_0);
            }
        } else {
            if (mScreenConfig.orientation.equals("landscape")) {
                mRenderView.setVideoRotation(VideoRotation.ROTATION_270);
            } else {
                mRenderView.setVideoRotation(VideoRotation.ROTATION_0);
            }
        }
    }
```

以上处理逻辑可以参考[SimpleDemo](../Demo/SimpleDemo.zip)
