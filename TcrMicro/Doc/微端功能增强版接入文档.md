# 功能增强版

功能增强版采用热更新的方式完成微端包到热更包的转化。

## 1.接入流程

### 1.1 集成步骤概述

1.生成云端包

在游戏原始包中接入云端SDK，添加登录/支付的逻辑，编译生成云端包，本地调试成功后，将云端包通过微信对接群给到腾讯的工作人员，我们会把云端包部署到我们的微端云游戏后台，待部署完成后，向工作人员获取部署的游戏ID，该游戏ID在微端包集成中会使用。详细流程请参考下文[生成云端包](#12-生成云端包)。

2.生成微端包

在微端APP示例工程的基础上进行二次开发，将生成的微端包保存。详细流程请参考下文[生成微端包](#13-生成微端包)。

3.生成补丁包

将游戏包通过命令行工具生成补丁包，将生成的补丁包通过微信对接群给到腾讯的工作人员，待工作人员上传完毕后，将微端包安装到手机上进行测试。详细流程请参考下文[生成补丁包](#14-生成补丁包)

### 1.2 生成云端包

云端包是在游戏原始包的基础上接入云端SDK，最终要部署运行到云游后台，提供和微端包数据交换的能力（可以用来传输登录/支付数据）。

**详细步骤**：

第一步，使用Android Studio打开游戏原始包。

第二步，打开app/build.gradle文件，添加云端SDK依赖。

```groovy
dependencies {
    implementation "com.tencent.tcr:micro-cloud-sdk:2.0.0"
}
```

第三步，在集成云端SDK之后，需要使用云端SDK的能力在游戏原始包中新增端口监听能力，并将监听的端口号提供给微端包，微端包通过该端口向云端包发送数据（登录/支付数据）。云端SDK的接口说明参考[云端SDK的API文档](云端SDK的API文档.zip)。

1）创建端口并监听微端包发送的数据

```java
   DataChannel.Listener listener = new DataChannel.Listener() {
        public void onReceive(byte[] buffer, int len) {
            // 从监听的端口接收到数据
            String dataFromRemote = new String(buffer, 0, len);
            Log.d(TAG, "receive local data=" + dataFromRemote);
        }

        public void onException(Exception e) {
            Log.e(TAG, "onException: " + e.getMessage());
            // 数据接收或发送过程中出现异常
            // TODO 处理异常
        }
    };
  
    //打开数据通道，开始监听
    mDataChannel = new DataChannel(listener, getUdpPortFromProperty());
    mDataChannel.open();
```

在onReceive中接收微端包传递的已经经过微端处理的登录消息，例如登录token信息，云端包获取到消息后进行相关处理。

2）发送数据给微端包

通过以下接口将消息发送给微端包，发送的数据可以自己定义。

```java
    /**
     * 通过此方法向发送方回复数据
     * 必须在数据通道连接成功后使用
     *
     * @param data 要发送的数据
     */
    public void sendData(String data) {
        if (mDataChannel != null) {
            Log.d(TAG, "sendData to local:" + data);
            mDataChannel.send(data.getBytes(Charset.forName("UTF-8")));
        }
    }
```

注意：发送数据必须在数据通道连接成功之后，发送数据必须在**非UI线程**中调用。

3）数据通道建立完毕后，请参考【功能实现：登录/支付穿透】完成云端包的改动。

第四步，本地调试，通过本地调试来验证端口是否能够正常通信。

新建一个测试APP(参考[数据通道本地测试](../Demo/云端APP示例工程/DataChannelTest.zip))，在测试APP中模拟数据的发送与接收。

同时打开测试APP和云端包，在测试APP中使用下面代码给端口DEST_PORT发送消息，查看云端包APP的Listener中是否能够正常收到该消息。

注意：需要提前打开云端包APP，通过Android提供的分屏模式，打开测试APP和云端包APP，在测试APP中发送测试消息，观察云端包APP是否可以收到该消息。

第五步，编译生成云端apk并部署到云端。

本地调试成功之后，clean工程，点击Android Studio的Gradle构建，使用assembleRelease编译生成云端apk，

将该apk给到微信对接群中的工作人员，待游戏部署成功后向工作人员获取游戏ID。

### 1.3 生成微端包

微端包用于广告投放，用户下载安装运行到手机上，可以云试玩和热更新到完整游戏包。您可以下载[微端体验APK](../Demo/微端APP示例工程/微端体验.apk)进行体验。

微端包的开发过程不需要从零开始，可以直接在[微端包示例工程](../Demo/微端APP示例工程/TcrMicroAppForUnity2018Empty.zip)的基础上进行二次开发，该工程中已经接入了微端SDK。

**准备工作**：

第一步，下载[微端包示例工程](../Demo/微端APP示例工程/TcrMicroAppForUnity2018Empty.zip)，解压之后使用AndroidStudio打开。

第二步，通过游戏原始包生成微端需要的AndroidManifest.xml文件。

在Terminal中进入到工程的hotUpdate目录下，使用以下命令生成AndroidManifest.xml：

```shell
./generate_manifest.sh 游戏原始apk路径
```

执行之后AndroidManifest.xml文件生成在hotUpdate/out目录下。

第三步，通过游戏原始包生成微端需要的R.txt文件。

在Terminal中进入到工程的hotUpdate目录下，使用以下命令生成R.txt：

```shell
./generate_resource_id.sh 游戏原始apk路径
```

执行之后R.txt文件生成在hotUpdate/out目录下。

**详细步骤**：

第一步，修改构建脚本。

打开app模块下的build.gradle文件，修改applicationId、minSdkVersion、targetSdkVersion与您的游戏工程一致。

```groovy
defaultConfig {
        // 应用名称和您的游戏包名一致
        applicationId "com.DefaultCompany.Unity2018Empty"
        // 与你的游戏版本保持一致
        minSdkVersion 21 // 微端SDK最低支持到16
        //noinspection ExpiredTargetSdkVersion,OldTargetApi
        targetSdkVersion 29 // 与你的游戏版本保持一致
        ndk {
            abiFilters 'armeabi-v7a', 'arm64-v8a'
        }
        versionCode rootProject.ext.versionCode
        versionName rootProject.ext.versionName
        multiDexEnabled true
        multiDexKeepProguard file('multidex-config.pro')
    }
```

修改签名文件与您的更新包工程一致。

```groovy
signingConfigs {
        release {
            keyAlias "testres"
            keyPassword "testres"
            storePassword "testres"
            storeFile file("keystore/micro.keystore")
        }
    }
```

第二步，替换AndroidManifest.xml文件。

将准备工作中获取的hotUpdate/out/AndroidManifest.xml文件拷贝到微端工程的对应目录下，替换工程的AndroidManifest.xml。在该文件里声明的Application类和4大组件类，在微端工程里不存在的，会编译报错，可以使用IDE的Quick Fix功能创建对应的空类占位。

第三步，修改工程代码。

将MyApplication和UnityPlayerActivity里的代码拷贝到新AndroidManifest.xml文件里声明的Application类和主Activity类里。把原MyApplication和UnityPlayerActivity类删掉。

第四步，修改工程配置。

打开工程assets下的microSettings.xml，修改对应参数

```xml
<?xml version="1.0" encoding="utf-8"?>
<settings>
    <!--    游戏ID。game-mkcru8bo(Unity2018)，game-h4c3xgp5(Unity2020)。-->
    <setting key="game_id" value="game-mkcru8bo" />
    <!--    patch存放的位置，功能增强版接入需要填入-->
    <setting key="patch_url"
            value="https://cg-sdk-1258344699.cos.ap-nanjing.myqcloud.com/micro/patch/TcrMicroAppForUnity2018Empty/patch.apk" />
    <!--    与云端通信的端口号-->
    <setting key="port" value="6666" />

    <!--    需要hook的so列表，value中写"libtest1.so,libtest2.so"，多个so之前用逗号隔开-->
    <setting key="hook_so_list" value="libunity.so" />
    <!--    是否需要hack app的资源存放路径，hack之后采用完整包中的资源-->
    <setting key="hack_app_dir" value="true" />
</settings>
```

将【云端SDK接入指南】中云端apk部署之后生成的游戏ID填入到game_id中，

在微信对接群中向工作人员获取补丁包的存放位置并填入到patch_url中。

将【云端SDK接入指南】中云端包开启的UDP端口填入到port中，没有使用登录/支付穿透功能可以不填。

第五步（可选），修改游戏启动背景。

替换assets中的loading.png即可替换游戏启动背景。

第六步（可选），如果您需要实现登录/支付穿透功能。

微端包在onReceiveCloudGameMessage接口中收到云端包发送的数据（例如，开始登录/支付）。

将登录/支付的结果通过sendDataToCloudGame方法通知给云端包。

```java
public class UnityPlayerActivity extends MicroBaseActivity {

    private boolean isConnectSuccess = false;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        Log.d(TAG, "onCreate: ");
        // 注意：云游戏启动时带的参数必须经过base64编码，否则会抛出crash（IllegalArgumentException）
        // gameParas为可选参数，不需要携带直接可以使用initConfig(BuildConfig.VERSION)进行初始化。
        String gameParas = "dGVzdCBkYXRhIGZvciBjbG91ZCBnYW1l"; // 经过base64编码之后的字符串（test data for cloud game）
        initConfig(BuildConfig.VERSION, gameParas);    // 初始化配置必须在父类onCreate之前
        super.onCreate(savedInstanceState);
    }

    @Override
    protected void onReceiveCloudGameMessage(String data) {
        // 接收云端游戏的返回信息
    }

    @Override
    protected void onDataChannelConnectSuccess() {
        // 连接成功后可以向云端游戏发送信息，例如登录或者支付的结果
        isConnectSuccess = true;
        sendConnectMsg();
    }

    // 向云端发送链接成功
    private void sendConnectMsg() {
        Log.d(TAG, "向云端发送连接成功消息");
        try {
            JSONObject jsonObject = new JSONObject();
            jsonObject.put("connected", "连接成功");
            sendDataToCloudGame(jsonObject.toString());
        } catch (Exception e) {
            e.printStackTrace();
            Log.e(TAG, "sendConnectMsg exception");
        }
    }
}
```

*注意：数据发送必须要在onDataCHannelConnectSuccess之后进行。*

第七步，生成微端APK。

修改micro-update-support.gradle文件里的baseApkDir值为hotUpdate。

将baseApkResourceMapping的路径修改为out/R.txt，其他配置无需更改。

```groovy

/**
 * 对于插件各参数的详细解析请参考
 */
tinkerSupport {

  ...

    def baseApkDir = "hotUpdate"

    ...

    // 对应tinker插件applyResourceMapping
    baseApkResourceMapping = "${baseApkDir}/out/R.txt"

  ...
}
```

clean整个工程，然后点击Android Studio的Gradle构建，使用assembleRelease编译工程源码，生成微端apk。

第八步，校验微端包生成是否正常。

在Terminal中进入到hotUpdate目录下，使用以下命令校验微端包：

```shell
./check_old_config.sh 微端apk路径 游戏原始包路径
```

可以正常校验通过没有ERROR信息即为正常。校验结果将生成到hotUpdate/check_result目录下。

### 1.4 生成补丁包

第一步，安装java11环境，在Terminal中进入到hotUpdate目录下，使用以下命令生成补丁包：

```shell
./generate_patch.sh 游戏原始包路径
```

补丁包生成路径为：hotUpdate/out/patch.apk。

第二步，本地调试验证。

在Terminal中进入到hotUpdate目录下，使用以下命令进行本地调试：

```shell
./local_debug.sh 微端apk路径 补丁包路径
```

注意：需要先adb连接要调试的设备

在手机上点击刚安装的apk，运行之后会提示“检测到本地补丁包“的弹窗，点击“加载补丁”选取刚才push到sd卡的补丁文件，选择完毕后悬浮球显示更新中，更新完成弹出“重启弹窗”，点击“立即重启“按钮，查看是否可以正常重启。

第三步，本地调试验证成功后，将补丁包通过微信对接群给到工作人员。

## 2.核心功能实现

### 2.1功能实现：静默下载

在云游戏微端试玩的基础上，我们还提供了在后台静默下载游戏包体（亦可按照客户需求，实现特异性的下载触发实现逻辑），以实现游戏投放的最终转化。

微端示例工程默认已实现该功能。

### 2.2 功能实现：登录/支付穿透

<img
src="https://docimg7.docs.qq.com/image/7QWjLfYrV-ERh6pR0lFN6g.png?w=1280&h=657.7628259041211" width="600px">

由于云端游戏限制，在云端实现登录/支付逻辑比较困难，所以需要将登录/支付的实现逻辑放到本地微端包中，微端包将处理结果通过数据通道传输给云端包。需要将游戏原始包中的原有登录/支付逻辑拆分到微端包和云端包中。

#### 2.2.1微端包改动

1.实现登录/支付的具体逻辑

具体逻辑参照游戏原始包中的登录/支付代码。

2.通过微端SDK中提供的接口（sendDataToCloudGame）将处理的结果传输给云端包。

例如：在登录成功之后通过数据通道发送数据给云端包

```java
    private void sendLoginCall(String authCode) {
        if (!isConnectSuccess) {
            Log.d(TAG, "未连接成功，不能向云端发送登录回调");
            return;
        }
        Log.d(TAG, "向云端发送登录回调");
        try {
            JSONObject jsonObject = new JSONObject();
            jsonObject.put("auth_code", authCode);
            sendDataToCloudGame(jsonObject.toString());
        } catch (JSONException e) {
            e.printStackTrace();
            Log.e(TAG, "sendLoginCall exception");
        }
    }
```

#### 2.2.2云端包改动

云端包需要在原始包的基础上将原有的登录/支付的实现逻辑从工程中移除，需要在发生登录/支付操作的地方，通过数据通道通知微端包进行相应的登录/支付操作。

例如：在需要登录时通过数据通道通知微端包（您可以自定义相关参数）

```java
mDataChannel.send("login".getBytes(Charset.forName("UTF-8")));
```

注意：send方法不能在主线程中调用，会引起crash。

待微端包处理完成后，接收微端包通过数据通道传递的登录/支付结果，继续执行后续代码逻辑。

## 3.资源汇总

[微端包示例工程](../Demo/微端APP示例工程/TcrMicroAppForUnity2018Empty.zip)

[游戏包示例工程](../Demo/游戏APP示例工程/AndroidUnity2018Empty.zip)

[云端包示例工程](../Demo/云端APP示例工程/TcrMicroCloud.zip)

[云端SDK的API文档](云端SDK的API文档.zip)

[微端体验APK](../Demo/微端APP示例工程/微端体验.apk)

## 4.注意事项（必读）

### 4.1 更新包的Proguard规则

如果app模块的build.gradle文件里设置了minifyEnabled和shrinkResources为true，则需注意默认的Proguard文件不能为proguard-android-optimize.txt，需修改为proguard-android.txt。因为R8的代码外联优化会破坏代码热更新机制。例如

```groovy
buildTypes {
    release {
        minifyEnabled true
        shrinkResources true
        proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
    }
}
```

### 4.2 更新包 minSDK<21时mutidex规则

**如果更新包工程的minSDK<21，则需要新增mutidex配置文件。**

在app目录下新建mutidex-config.pro文件，在该文件中新增以下内容。

```groovy
-keep class com.tencent.bugly.beta.tinker.**{*;}
-keep class com.bytedance.android.** {*;}
-keep class com.tencent.tinker.** {*;}
-keep class androidx.multidex.**{*;}
```

同时在app模块的build.gradle文件中新增对mutidex-config.pro文件的引用。

```groovy
defaultConfig {
    ...
    multiDexEnabled true
    multiDexKeepProguard file('multidex-config.pro')
}
```

最后需要把补丁包生成工具的配置文件tinker_config.xml中的allowLoaderInAnyDex和removeLoaderForAllDex改为false。

```xml
<issue id="property">
        ......
        
        <!-- use in minSDK>=21 -->
        <!-- when minSDK<21, please make allowLoaderInAnyDex and removeLoaderForAllDex all false-->
        <allowLoaderInAnyDex value="true" />
        <removeLoaderForAllDex value="true" />
</issue>
```

### 4.3 微端包和云端包数据通道使用

微端APP收到数据通道连接成功的回调onDataCHannelConnectSuccess，需要通过数据通道向云端APP发送一条数据，这样才能保证云端APP获取到微端APP发送时的端口号，云端APP才能正常发送数据到微端APP。
