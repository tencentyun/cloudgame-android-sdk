# 功能增强版

功能增强版采用热更新的方式完成微端包到热更包的转化，热更新转化失败后采取安装apk的方式进行兜底更新。

## 1.接入流程

### 1.1 集成步骤概述

由于各模块之间存在依赖关系，您需要按照以下顺序完成集成的工作。

1.[生成云端包](#12-生成云端包)

在游戏原始包中接入云端SDK，添加登录/支付的逻辑，编译生成云端包，本地调试成功后，将云端包通过微信

对接群给到腾讯的工作人员，我们会把云端包部署到我们的微端云游戏后台，待部署完成后，向工作人员获取部

署的游戏ID，该游戏ID在微端包集成中会使用。详细流程请参考【生成云端包】

2.[生成更新包](#13-生成更新包)

对游戏包进行简单适配即可生成更新包。详细流程请参考【生成更新包】。

3.[生成补丁包](#14-生成补丁包)

将保存的微端包和更新包通过命令行工具生成补丁包，请参考【生成补丁包】，将生成的补丁包通过微信对接群给到腾讯的工作人员，待工作人员上传完毕后，将微端包安装到手机上进行测试。

4.[生成微端包](#15-生成微端包)

在微端APP示例工程的基础上进行二次开发，将生成的微端包保存，详细流程请参考【生成微端包】。

### 1.2 生成云端包

云端包是在游戏原始包的基础上接入云端SDK，最终要部署运行到云游后台，提供和微端包数据交换的能力（可以用来传输登录/支付数据）。

**详细步骤**：

第一步，使用Android Studio打开游戏原始包。

第二步，打开app/build.gradle文件，添加云端SDK依赖。

```groovy
dependencies {
    implementation "com.tencent.tcr:micro-cloud-sdk:2.0.0"
}
```

第三步，在集成云端SDK之后，需要使用云端SDK的能力在游戏原始包中新增端口监听能力，并将监听的端口号提供给微端包，微端包通过该端口向云端包发送数据（登录/支付数据）。参考：[云端SDK使用文档](云端SDK使用文档.zip)

1）创建端口并监听微端包发送的数据

```java
   DataChannel.Listener listener = new DataChannel.Listener() {
        public void onReceive(byte[] buffer, int len) {
            // 从监听的端口接收到数据
            String dataFromRemote = new String(buffer, 0, len);
            Log.d(TAG, "receive local data=" + dataFromRemote);
        }

        public void onException(Exception e) {
            Log.e(TAG, "onException: " + e.getMessage());
            // 数据接收或发送过程中出现异常
            // TODO 处理异常
        }
    };
  
    //打开数据通道，开始监听
    mDataChannel = new DataChannel(listener, getUdpPortFromProperty());
    mDataChannel.open();
```

在onReceive中接收微端包传递的已经经过微端处理的登录消息，例如登录token信息，云端包获取到消息后进行相关处理。

2）发送数据给微端包

通过以下接口将消息发送给微端包，发送的数据可以自己定义。

```java
    /**
     * 通过此方法向发送方回复数据
     * 必须在数据通道连接成功后使用
     *
     * @param data 要发送的数据
     */
    public void sendData(String data) {
        if (mDataChannel != null) {
            Log.d(TAG, "sendData to local:" + data);
            mDataChannel.send(data.getBytes(Charset.forName("UTF-8")));
        }
    }
```

注意：发送数据必须在数据通道连接成功之后，发送数据必须在**工作线程**中调用。

3）数据通道建立完毕后，请参考【功能实现：登录/支付穿透】完成云端包的改动。

第四步，本地调试，通过本地调试来验证端口是否能够正常通信。

新建一个测试APP(参考[数据通道本地测试](../Demo/云端APP示例工程/DataChannelTest.zip))，在测试APP中模拟数据的发送与接收。

同时打开测试APP和云端包，在测试APP中使用下面代码给端口DEST_PORT发送消息，查看云端包APP的Listener中是否能够正常收到该消息。

注意：需要提前打开云端包APP，通过Android提供的分屏模式，打开测试APP和云端包APP，在测试APP中发送测试消息，观察云端包APP是否可以收到该消息。

第五步，编译生成云端apk并部署到云端。

本地调试成功之后，clean工程，点击Android Studio的Gradle构建，使用assembleRelease编译生成云端apk，

将该apk给到微信对接群中的工作人员，待游戏部署成功后向工作人员获取游戏ID。

### 1.3 生成更新包

更新包不被安装运行，它的作用是生成补丁包、获取微端包需要的R文件和清单文件。

第一步【可选】，如果游戏工程不存在自定义Application，请创建对应的Application，已经存在自定义Application可以跳过这一步。

```java
package com.unity3d.player;

import android.app.Application;

public class MyApplication extends Application {
// 可以什么也不做
}
```

创建完成后将该Application填入到AndroidManifest.xml的application标签下。

第二步，生成更新包构建物。

clean工程，点击Android Studio的Gradle构建，使用assembleRelease编译生成构建物，

需要保存的构建物有三个：

1. 更新包apk，位置在build/outputs/apk/release/xxx-release.apk。

2. R文件，位置在build/intermediates/runtime_symbol_list/release/R.txt。

3. 清单文件，位置在src/main/AndroidManifest.xml。

后续在生成微端包的步骤中需要用到R文件和清单文件，在生成补丁包的步骤中需要用到更新包apk。

### 1.4 生成补丁包

第一步，安装java11环境，下载[补丁包生成工具](../Tools)。

第二步，生成补丁包。

将[生成更新包](#13-生成更新包)小节中生成的更新包apk拷贝到hotUpdate目录下，重命名为new.apk。

在Terminal中进入到Tools目录下，使用以下命令生成补丁包,

```shell
./generate_patch.sh
```

生成的产物为hotUpdate/patch.apk。

### 1.5 生成微端包

微端APK是最终投放给用户的，用户下载安装运行到手机上，提供云试玩和热更新到更新游戏的能力。您可以下载[微端体验APK](../Demo/微端APP示例工程/微端体验.apk)进行体验。

微端包的开发过程不需要从零开始，可以直接在[微端包示例工程](../Demo/微端APP示例工程/TcrMicroAppForUnity2018Empty.zip)的基础上进行二次开发，该工程中已经接入了微端SDK。

以下介绍详细步骤：

第一步，下载[微端包示例工程](../Demo/微端APP示例工程/TcrMicroAppForUnity2018Empty.zip)，使用AndroidStudio打开。

第二步，修改构建脚本。打开app模块下的build.gradle文件，修改applicationId、minSdkVersion、targetSdkVersion与您的游戏工程一致。

```groovy
defaultConfig {
        // 应用名称和您的游戏包名一致
        applicationId "com.DefaultCompany.Unity2018Empty"
        // 与你的游戏版本保持一致
        minSdkVersion 21 // 微端SDK最低支持到16
        //noinspection ExpiredTargetSdkVersion,OldTargetApi
        targetSdkVersion 29 // 与你的游戏版本保持一致
        ndk {
            abiFilters 'armeabi-v7a', 'arm64-v8a'
        }
        versionCode rootProject.ext.versionCode
        versionName rootProject.ext.versionName
        multiDexEnabled true
        multiDexKeepProguard file('multidex-config.pro')
    }
```

修改签名文件与您的更新包工程一致。

```groovy
signingConfigs {
        release {
            keyAlias "testres"
            keyPassword "testres"
            storePassword "testres"
            storeFile file("keystore/micro.keystore")
        }
    }
```

第三步，替换和修改AndroidManifest.xml文件。

将更新包中获取的AndroidManifest.xml文件拷贝到微端工程的对应目录下，替换同名文件。在该文件里声明的Application类和4大组件类，在微端工程里不存在的，会编译报错，可以使用IDE的Quick Fix功能创建对应的空类占位。

第四步，修改工程代码。

将MyApplication和UnityPlayerActivity里的代码拷贝到第三步新AndroidManifest.xml文件里声明的Application类和主Activity类里。把原MyApplication和UnityPlayerActivity类删掉。

第五步，修改工程配置。

打开工程assets下的microSettings.xml，修改对应参数

```xml
<?xml version="1.0" encoding="utf-8"?>
<settings>
    <!--    游戏ID。game-mkcru8bo(Unity2018)，game-h4c3xgp5(Unity2020)。-->
    <setting key="game_id" value="game-mkcru8bo" />
    <!--    patch存放的位置，功能增强版接入需要填入-->
    <setting key="patch_url"
            value="https://cg-sdk-1258344699.cos.ap-nanjing.myqcloud.com/micro/patch/TcrMicroAppForUnity2018Empty/patch.apk" />
    <!--    与云端通信的端口号-->
    <setting key="port" value="6666" />

    <!--    需要hook的so列表，value中写"libtest1.so,libtest2.so"，多个so之前用逗号隔开-->
    <setting key="hook_so_list" value="libunity.so" />
    <!--    是否需要hack app的资源存放路径，hack之后采用完整包中的资源-->
    <setting key="hack_app_dir" value="true" />
</settings>
```

将【云端SDK接入指南】中云端apk部署之后生成的游戏ID填入到game_id中，

在微信对接群中向工作人员获取补丁包的存放位置并填入到patch_url中。

将【云端SDK接入指南】中云端包开启的UDP端口填入到port中，没有使用登录/支付穿透功能可以不填。

第六步（可选），修改游戏启动背景。

替换assets中的loading.png即可替换游戏启动背景。

第六步（可选），如果您需要实现登录/支付穿透功能。

微端包在onReceiveCloudGameMessage接口中收到云端包发送的数据（例如，开始登录/支付）。

将登录/支付的结果通过sendDataToCloudGame方法通知给云端包。

```java
public class UnityPlayerActivity extends MicroBaseActivity {

    private boolean isConnectSuccess = false;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        Log.d(TAG, "onCreate: ");
        // 注意：云游戏启动时带的参数必须经过base64编码，否则会抛出crash（IllegalArgumentException）
        // gameParas为可选参数，不需要携带直接可以使用initConfig(BuildConfig.VERSION)进行初始化。
        String gameParas = "dGVzdCBkYXRhIGZvciBjbG91ZCBnYW1l"; // 经过base64编码之后的字符串（test data for cloud game）
        initConfig(BuildConfig.VERSION, gameParas);    // 初始化配置必须在父类onCreate之前
        super.onCreate(savedInstanceState);
    }

    @Override
    protected void onReceiveCloudGameMessage(String data) {
        // 接收云端游戏的返回信息
    }

    @Override
    protected void onDataChannelConnectSuccess() {
        // 连接成功后可以向云端游戏发送信息，例如登录或者支付的结果
        isConnectSuccess = true;
        sendConnectMsg();
    }

    // 向云端发送链接成功
    private void sendConnectMsg() {
        Log.d(TAG, "向云端发送连接成功消息");
        try {
            JSONObject jsonObject = new JSONObject();
            jsonObject.put("connected", "连接成功");
            sendDataToCloudGame(jsonObject.toString());
        } catch (Exception e) {
            e.printStackTrace();
            Log.e(TAG, "sendConnectMsg exception");
        }
    }
}
```

*注意：数据发送必须要在onDataCHannelConnectSuccess之后进行。*

第七步，生成微端APK。

在微端包的工程根目录下新建hotUpdate文件夹，

将1.3节更新包工程里生成的R.txt拷贝到hotUpdate文件夹下。

修改micro-update-support.gradle文件里的baseApkDir值为hotUpdate。

将baseApkResourceMapping的路径修改为R.txt，其他配置无需更改。

```groovy

/**
 * 对于插件各参数的详细解析请参考
 */
tinkerSupport {

  ...

    def baseApkDir = "hotUpdate"

    ...

    // 对应tinker插件applyResourceMapping
    baseApkResourceMapping = "${baseApkDir}/R.txt"

  ...
}
```

clean整个工程，然后点击Android Studio的Gradle构建，使用assembleRelease编译工程源码，生成微端apk。

第八步，校验微端包生成是否正常。

将微端apk拷贝到Tools/hotUpdate目录下，并命名为old.apk。

在Terminal中进入到Tools目录下，使用以下命令校验微端包：

```shell
./check_old_config.sh
```

可以正常校验通过没有ERROR信息即为正常。

如果有问题，请检查清单文件的替换是否成功。

第九步，本地调试验证。

将生成的补丁包通过adb push到SD卡Download目录。

卸载之前的微端包，安装新的微端包（old.apk）。

```shell
## 手机中没有Download目录的需要提前创建
adb shell mkdir -p /storage/emulated/0/Download

adb push hotUpdate/patch.apk /storage/emulated/0/Download

adb install hotUpdate/old.apk
```

安装微端apk到手机，运行之后会提示“检测到本地补丁包“的弹窗，点击“加载补丁”选取刚才push到sd卡的补丁文件，选择完毕后悬浮球显示更新中，更新完成弹出“重启弹窗”，点击“立即重启“按钮。

*注：本地调试时可以过滤log查看patch加载信息*，

```shell
adb logcat | grep Tinker
```

第五步，本地调试验证成功后，将补丁包通过微信对接群给到工作人员。

## 2.核心功能实现

### 2.1功能实现：静默下载

在云游戏微端试玩的基础上，我们还提供了在后台静默下载游戏包体（亦可按照客户需求，实现特异性的下载触发实现逻辑），以实现游戏投放的最终转化。

微端示例工程默认已实现该功能。

### 2.2 功能实现：登录/支付穿透

<img
src="https://docimg7.docs.qq.com/image/7QWjLfYrV-ERh6pR0lFN6g.png?w=1280&h=657.7628259041211" width="600px">

由于云端游戏限制，在云端实现登录/支付逻辑比较困难，所以需要将登录/支付的实现逻辑放到本地微端包中，微端包将处理结果通过数据通道传输给云端包。需要将游戏原始包中的原有登录/支付逻辑拆分到微端包和云端包中。

#### 2.2.1微端包改动

1.实现登录/支付的具体逻辑

具体逻辑参照游戏原始包中的登录/支付代码。

2.通过微端SDK中提供的接口（sendDataToCloudGame）将处理的结果传输给云端包。

例如：在登录成功之后通过数据通道发送数据给云端包

```java
    private void sendLoginCall(String authCode) {
        if (!isConnectSuccess) {
            Log.d(TAG, "未连接成功，不能向云端发送登录回调");
            return;
        }
        Log.d(TAG, "向云端发送登录回调");
        try {
            JSONObject jsonObject = new JSONObject();
            jsonObject.put("auth_code", authCode);
            sendDataToCloudGame(jsonObject.toString());
        } catch (JSONException e) {
            e.printStackTrace();
            Log.e(TAG, "sendLoginCall exception");
        }
    }
```

#### 2.2.2云端包改动

云端包需要在原始包的基础上将原有的登录/支付的实现逻辑从工程中移除，需要在发生登录/支付操作的地方，通过数据通道通知微端包进行相应的登录/支付操作。

例如：在需要登录时通过数据通道通知微端包（您可以自定义相关参数）

```java
mDataChannel.send("login".getBytes(Charset.forName("UTF-8")));
```

注意：send方法不能在主线程中调用，会引起crash。

待微端包处理完成后，接收微端包通过数据通道传递的登录/支付结果，继续执行后续代码逻辑。

## 3.资源汇总

[微端包示例工程](../Demo/微端APP示例工程/TcrMicroAppForUnity2018Empty.zip)

[更新包示例工程](../Demo/热更APP示例工程/AndroidUnity2018Empty.zip)

[云端包示例工程](../Demo/云端APP示例工程/TcrMicroCloud.zip)

[云端SDK使用文档](云端SDK使用文档.zip)

[微端体验APK](../Demo/微端APP示例工程/微端体验.apk)

[补丁包生成工具](../Tools)

## 4.注意事项（必读）

### 4.1 更新包的Proguard规则

如果app模块的build.gradle文件里设置了minifyEnabled和shrinkResources为true，则需注意默认的Proguard文件不能为proguard-android-optimize.txt，需修改为proguard-android.txt。因为R8的代码外联优化会破坏代码热更新机制。例如

```groovy
buildTypes {
    release {
        minifyEnabled true
        shrinkResources true
        proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
    }
}
```

### 4.2 更新包 minSDK<21时mutidex规则

**如果更新包工程的minSDK<21，则需要新增mutidex配置文件。**

在app目录下新建mutidex-config.pro文件，在该文件中新增以下内容。

```groovy
-keep class com.tencent.bugly.beta.tinker.**{*;}
-keep class com.bytedance.android.** {*;}
-keep class com.tencent.tinker.** {*;}
-keep class androidx.multidex.**{*;}
```

同时在app模块的build.gradle文件中新增对mutidex-config.pro文件的引用。

```groovy
defaultConfig {
    ...
    multiDexEnabled true
    multiDexKeepProguard file('multidex-config.pro')
}
```

最后需要把补丁包生成工具的配置文件tinker_config.xml中的allowLoaderInAnyDex和removeLoaderForAllDex改为false。

```xml
<issue id="property">
        ......
        
        <!-- use in minSDK>=21 -->
        <!-- when minSDK<21, please make allowLoaderInAnyDex and removeLoaderForAllDex all false-->
        <allowLoaderInAnyDex value="true" />
        <removeLoaderForAllDex value="true" />
</issue>
```

### 4.3 微端包和云端包数据通道使用

微端APP收到数据通道连接成功的回调onDataCHannelConnectSuccess，需要通过数据通道向云端APP发送一条数据，这样才能保证云端APP获取到微端APP发送时的端口号，云端APP才能正常发送数据到微端APP。

### 4.4 无法在构建产物中获取到R文件

由于apk构建方法或者其他原因导致无法获取到中间产物R.txt，可以通过以下脚本从完整apk中提取R文件：

```java
# 添加Android SDK 中aapt2的环境变量
//sdk存放路径
export ANDROID_HOME=/Users/你的用户名/Library/Android/sdk 
//没有31.0.0其他版本也可以
export PATH=${PATH}:${ANDROID_HOME}/build-tools/31.0.0 
// 提取R文件
aapt2 dump resources $1 --no-values | grep resource | sed 's/\// /' | awk '{printf "int "$3" "$4" "$2"\n"}' | sed 's/\./_/' > R.txt
```

详情请参考[微端包示例工程](../Demo/微端APP示例工程/TcrMicroAppForUnity2018Empty.zip)中的generate_resource_id.sh。

### 4.5 无法获取完整apk中的清单文件

由于无法拿到完整包源码或者其他原因，可以通过以下脚本获取清单文件：

```java
//通过apktool获取AndroidManifest.xml
java -jar tools/apktool_2.6.0.jar d hotUpdate/new.apk 
```

详情请参考[微端包示例工程](../Demo/微端APP示例工程/TcrMicroAppForUnity2018Empty.zip)中的generate_manifest.sh。
