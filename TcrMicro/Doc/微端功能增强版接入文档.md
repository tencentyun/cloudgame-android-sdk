# 功能增强版

功能增强版采用热更新的方式完成微端包到热更包的转化，热更新转化失败后采取安装apk的方式进行兜底更新。

## 1.接入流程

### 1.1 集成步骤概述

由于各模块之间存在依赖关系，您需要按照以下顺序完成集成的工作。

1.生成云端包

在游戏原始包中接入云端SDK，添加登录/支付的逻辑，编译生成云端包，本地调试成功后，将云端包通过微信

对接群给到腾讯的工作人员，我们会把云端包部署到我们的微端云游戏后台，待部署完成后，向工作人员获取部

署的游戏ID，该游戏ID在微端包集成中会使用。详细流程请参考【生成云端包】

2.生成更新包

对游戏包进行简单适配即可生成更新包。详细流程请参考【生成更新包】。

3.生成微端包

在微端APP示例工程的基础上进行二次开发，将生成的微端包保存，详细流程请参考【生成微端包】。

4.生成补丁包

将保存的微端包和更新包通过命令行工具生成补丁包，请参考【生成补丁包】，将生成的补丁包通过微信对接群给到腾讯的工作人员，待工作人员上传完毕后，将微端包安装到手机上进行测试。

### 1.2 生成云端包

云端包是在游戏原始包的基础上接入云端SDK，最终要部署运行到云游后台，提供和微端包数据交换的能力（可以用来传输登录/支付数据）。

**详细步骤**：

第一步，使用Android Studio打开游戏原始包。

第二步，打开app/build.gradle文件，添加云端SDK依赖。

```groovy
dependencies {
    implementation "com.tencent.tcr:cloud:latest.release"
}
```

第三步，在集成云端SDK之后，需要使用云端SDK的能力在游戏原始包中新增端口监听能力，并将监听的端口号提供给微端包，微端包通过该端口向云端包发送数据（登录/支付数据）。参考：[云端SDK使用文档](云端SDK使用文档.zip)

1）创建端口并监听微端包发送的数据

```java
   DatagramSocketThread.Listener listener = new Listener() {
        public void onReceive(byte[] buffer, int len) {
            // 从监听的端口接收到数据
            String dataFromRemote = new String(buffer, 0, len);
        }
        public void onException(Exception e) {
            // 数据接收或发送过程中出现异常
        }
    };
  
    socketThread = new DatagramSocketThread(listener, DEST_PORT);
    socketThread.start();
```

在onReceive中接收微端包传递的已经经过微端处理的登录消息，例如登录token信息，微端包获取到消息后进行处理。

2）发送数据给微端包

在游戏需要登录的地方，通过以下接口将消息发送给微端包，发送的数据可以自己定义。

```java
socketThread.sendData("data".getBytes(StandardCharsets.UTF_8));
```

注意：发送数据必须在数据通道连接成功之后，发送数据必须在工作线程中。

3）数据通道建立完毕后，请参考【功能实现：登录/支付穿透】完成云端包的改动。

第四步，本地调试，通过本地调试来验证端口是否能够正常通信。

新建一个测试APP，在测试APP中创建一个本地线程，同时打开测试APP和云端包，在测试APP中使用下面代码给端口DEST_PORT发送消息，查看云端包APP的Listener中是否能够正常收到该消息。

注意：需要提前打开云端包APP，通过Android提供的分屏模式，打开测试APP和云端包APP，在测试APP中发送测试消息，观察云端包APP是否可以收到该消息。

```java
// 创建一个本地socket
DatagramSocket socket = new DatagramSocket();
InetAddress address = InetAddress.getByName("localhost");
// 给UDP
DatagramPacket packet = new DatagramPacket("data".getBytes(Charset.forName("UTF-8")), toastTest.length(), address, DEST_PORT);
Log.i(TAG, "send clientSendMsg");
socket.send(packet);
```

第五步，编译生成云端apk并部署到云端。

本地调试成功之后，clean工程，点击Android Studio的Gradle构建，使用assembleRelease编译生成云端apk，

将该apk给到微信对接群中的工作人员，待游戏部署成功后向工作人员获取游戏ID。

<img src="https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1MTEyNTg4NjQyOA_632895_lvfYeTlVuzy7HFME_1640073623?w=634&h=672" alt="img" width="300px" />
<img src="https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1MTEyNTg4NjQyOA_19167_YLu1h3SI67qgKUMU_1640073654?w=580&h=490" alt="img" width="300px" />

### 1.3 生成更新包

更新包不被安装运行，它的作用是和微端包对比生成补丁包。生成更新包的工程是由原始游戏工程集成热更新框架而成。下面详细介绍构建更新包工程和APK的步骤：

第一步，如果游戏工程不存在自定义Application，请创建对应的Application，已经存在自定义Application可以跳过这一步。

```java
package com.unity3d.player;


import android.app.Application;

public class MyApplication extends Application {
// 可以什么也不做
}
```

创建完成后将该Application填入到AndroidManifest.xml的application标签下。

第二步，生成更新包构建物。

clean工程，点击Android Studio的Gradle构建，使用assembleRelease编译生成构建物（apk[build/outputs/apk/release/xxx-release.apk]、和R文件[build/intermediates/runtime_symbol_list/release/R.txt]），如下图。

<img src="https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1MTQxODI3NTY4MA_976490_64fnokpkZQz93GSJ_1641455749?w=742&h=842" alt="img" width="300px" />  

### 1.4 生成微端包

微端APK是最终投放给用户的，用户下载安装运行到手机上，提供云试玩和热更新到更新游戏的能力。您可以下载[微端体验APK](../Demo/微端APP示例工程/微端体验.apk)进行体验。

微端包的开发过程不需要从零开始，可以直接在[微端包示例工程](../Demo/微端APP示例工程/TcrMicroAppForUnity2018Empty.zip)的基础上进行二次开发，该工程中已经接入了微端SDK和热更新SDK。 以下介绍详细步骤：

第一步，下载[微端包示例工程](../Demo/微端APP示例工程/TcrMicroAppForUnity2018Empty.zip)，使用AndroidStudio打开。

第二步，修改构建脚本。打开app模块下的build.gradle文件，修改applicationId、minSdkVersion、targetSdkVersion与您的游戏工程一致。

```groovy
defaultConfig {
        // 应用名称和您的游戏包名一致
        applicationId "com.DefaultCompany.Unity2018Empty"
        // 与你的游戏版本保持一致
        minSdkVersion 21 // 微端SDK最低支持到16
        //noinspection ExpiredTargetSdkVersion,OldTargetApi
        targetSdkVersion 29 // 与你的游戏版本保持一致
        ndk {
            abiFilters 'armeabi-v7a', 'arm64-v8a'
        }
        versionCode rootProject.ext.versionCode
        versionName rootProject.ext.versionName
        multiDexEnabled true
        multiDexKeepProguard file('multidex-config.pro')
    }
```

修改签名文件与您的更新包工程一致。

```groovy
signingConfigs {
        release {
            keyAlias "testres"
            keyPassword "testres"
            storePassword "testres"
            storeFile file("keystore/micro.keystore")
        }
    }
```

第三步，替换和修改AndroidManifest.xml文件。

将更新包的AndroidManifest.xml文件拷贝到微端工程的对应目录下，替换同名文件。在该文件里声明的Application类和4大组件类，在微端工程里不存在的，会编译报错，可以使用IDE的Quick Fix功能创建对应的空类占位。

第四步，修改工程代码。

将MyApplication和UnityPlayerActivity里的代码拷贝到第三步新AndroidManifest.xml文件里声明的Application类和主Activity类里。把原MyApplication和UnityPlayerActivity类删掉。

修改Config类的GAME_ID、PATCH_URL、PORT变量

```java
public class Config {

    // 游戏ID
    public static final String GAME_ID = "game-mkcru8bo";
    // Patch包下载地址
    public static final String PATCH_URL =
            "https://recorder-10018504.cos.ap-shanghai.myqcloud.com/shaw/patch/test/" + BuildConfig.PATCH_NAME;
    public static final String APK_URL = "";

    // 与云端通信的端口号
    public static int PORT = 6666;
}

```

将【云端SDK接入指南】中云端apk部署之后生成的游戏ID填入到GAME_ID中，

在微信对接群中向工作人员获取补丁包的下载地址并填入到PATCH_URL中。

将【云端SDK接入指南】中云端包开启的UDP端口填入到PORT中，没有使用登录/支付穿透功能可以不填。

APK_URL为**可选**内容，作为热更新失败时的保底策略，如果需要请把游戏完整包的下载地址填入。同时需要在AndroidManifest.xml的Application标签下新增如下内容：

```xml
<!--可选，如果采用了热更新失败apk兜底策略，请新增该provider -->
<provider
    android:name="androidx.core.content.FileProvider"
    android:authorities="${applicationId}.provider"
    android:exported="false"
    android:grantUriPermissions="true">
    <meta-data
        android:name="android.support.FILE_PROVIDER_PATHS"
        android:resource="@xml/micro_filepaths" />
</provider>
```

第五步（可选），修改游戏启动背景。

打开工程的res目录替换其中的game_background.jpg。

<img src="https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1MTEyNTg4NjQyOA_367155_eJCwyWG8YH9dqaAE_1647934269?w=642&h=216" alt="img" width="300px" />

第六步（可选），如果您需要实现登录/支付穿透功能。

微端包在onReceiveCloudGameMessage接口中收到云端包发送的数据（例如，开始登录/支付）。将登录/支付的结果通过sendDataToCloudGame方法通知给云端包。

```java
public class UnityPlayerActivity extends MicroBaseActivity {

    private static final String TAG = Constant.TAG + "[MainActivity]";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        Log.d(TAG, "onCreate: ");
        // 初始化配置必须在父类onCreate之前
        initConfig(Config.GAME_ID, Config.PATCH_URL, Config.PORT, BuildConfig.VERSION,
                ContextCompat.getDrawable(this, R.drawable.game_background));
        super.onCreate(savedInstanceState);
    }

    @Override
    protected void onReceiveCloudGameMessage(String data) {
        // TODO 在此处处理云端游戏的返回信息
        Log.d(TAG, "onReceiveCloudGameMessage: " + data);
    }

    @Override
    protected void onDataChannelConnectSuccess() {
        // TODO 连接成功后可以向云端游戏发送信息，例如登录或者支付的结果
        sendDataToCloudGame("this is test data from local");
    }
}

```

*注意：数据发送必须要在onDataCHannelConnectSuccess之后进行。*

第七步，生成微端APK。

在微端包的工程根目录下新建hotUpdate文件夹，

将1.3节更新包工程里生成的构建物（xxx.apk和R.txt）拷贝到hotUpdate文件夹下。

修改tinker-support.gradle文件里的baseApkDir值为hotUpdate。

同时将baseApk的apk路径改为xxx.apk（刚拷贝到hotUpdate中的apk），

将baseApkResourceMapping的路径修改为R.txt。

注意：如果更新包发生修改，需要重新将更新包的构建物拷贝到hotUpdate文件夹下。

```groovy

/**
 * 对于插件各参数的详细解析请参考
 */
tinkerSupport {

  ...

    // 编译补丁包时，必需指定基线版本的apk，默认值为空
    // 如果为空，则表示不是进行补丁包的编译
    // @{link tinkerPatch.oldApk }
    baseApk = "${baseApkDir}/xxx.apk"

    // 对应tinker插件applyMapping，可以不修改
    baseApkProguardMapping = "${baseApkDir}/app-release-mapping.txt"

    // 对应tinker插件applyResourceMapping
    baseApkResourceMapping = "${baseApkDir}/xxx-R.txt"

  ...
}
```

clean整个工程，然后点击Android Studio的Gradle构建，使用assembleRelease编译工程源码，生成微端apk。

### 1.5 生成补丁包

第一步，安装java11环境，下载[补丁包生成工具](../Tools/tinker-patch-cli-1.9.14.18.jar)，解压文件，将其中的[release.keystore](../Tools/release.keystore)替换为您的签名文件  

<img src="https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1MTEyNTg4NjQyOA_685235_-VKlsghszTFIzKDn_1647934344?w=1052&h=310" width="600px">

第二步，修改配置文件。

打开[tinker_config.xml](../Tools/tinker_config.xml)文件，修改签名文件的密钥，

<img src="https://docimg2.docs.qq.com/image/Qm7n65bcz4xvckeLy3q1Rw.png?w=1250&h=470" width="600px">

第三步，生成补丁包。

将前面生成的微端apk拷贝到tools目录下，重命名为old.apk。将前面生成的更新包apk拷贝到tools目录下，重命名为new.apk。

在Terminal中进入到tools目录下，使用以下命令生成补丁包

```shell
java -jar tinker-patch-cli-1.9.14.18.jar -old old.apk -new new.apk -config tinker_config.xml -out patch
```

第四步，本地调试验证。

将生成的补丁包通过adb push到SD卡Download目录。

```shell
## 手机中没有Download目录的需要提前创建
adb shell mkdir -p /storage/emulated/0/Download

adb push patch/patch_signed.apk /storage/emulated/0/Download
```

打开本地调试模式（通过adb shell进入手机命令行，设置属性）

```shell
adb shell setprop log.tag.local_apply_patch true
```

安装微端apk到手机，运行之后会提示“检测到本地补丁包“的弹窗，点击“加载补丁”选取刚才push到sd卡的补丁文件，选择完毕后悬浮球显示更新中，更新完成弹出“重启弹窗”，点击“立即重启“按钮。

*注：本地调试时可以过滤log查看patch加载信息*，

```shell
adb logcat | grep Tinker
```

第五步，本地调试验证成功后，将补丁包通过微信对接群给到工作人员。

## 2.核心功能实现

### 2.1功能实现：静默下载

在云游戏微端试玩的基础上，我们还提供了在后台静默下载游戏包体（亦可按照客户需求，实现特异性的下载触发实现逻辑），以实现游戏投放的最终转化。

完成  **3.接入流程**，即已实现该功能。

### 2.2 功能实现：登录/支付穿透

<img src="https://docimg7.docs.qq.com/image/7QWjLfYrV-ERh6pR0lFN6g.png?w=1280&h=657.7628259041211" width="600px">

由于云端游戏限制，在云端实现登录/支付逻辑比较困难，所以需要将登录/支付的实现逻辑放到本地微端包中，微端包将处理结果通过数据通道传输给云端包。需要将游戏原始包中的原有登录/支付逻辑拆分到微端包和云端包中。

**特别注意**：
云端包和微端包开启数据通道连接成功之后（onDataChannelConnectSuccess发生回调），微端包必须先发一条消息，例如{"connect":"true"}，告知云端包本地数据通道已经连接成功，云端包收到这条消息之后，才可以向微端包传递业务数据。

#### 2.2.1微端包改动

1.实现登录/支付的具体逻辑

具体逻辑参照游戏原始包中的登录/支付代码。

2.通过微端SDK中提供的接口（sendDataToCloudGame）将处理的结果传输给云端包。

*例如：在登录成功之后通过数据通道发送数据给云端包*

```java
String loginData = "{\"Access_Token\":\"edce2fbbf748df1d1d0ca3d6f\",\"OpenID\":1234567}";
sendDataToCloudGame(loginData));
```

#### 2.2.2云端包改动

云端包需要在原始包的基础上将原有的登录/支付的实现逻辑从工程中移除，需要在发生登录/支付操作的地方，通过数据通道通知微端包进行相应的登录/支付操作。

例如：在需要登录时通过数据通道通知微端包（您可以自定义相关参数）

```java
socketThread.sendData("login".getBytes(StandardCharsets.UTF_8));
```

注意：sendData不能在主线程中调用，会引起crash。

待微端包处理完成后，接收微端包通过数据通道传递的登录/支付结果，继续执行后续代码逻辑。

## **3.资源汇总**

[微端包示例工程](../Demo/微端APP示例工程/TcrMicroAppForUnity2018Empty.zip)

[更新包示例工程](../Demo/热更APP示例工程/AndroidUnity2018Empty.zip)

[云端包示例工程](../Demo/云端APP示例工程/TcrMicroCloud.zip)

[云端SDK使用文档](云端SDK使用文档.zip)

[微端体验APK](../Demo/微端APP示例工程/微端体验.apk)

[补丁包生成工具](../Tools/tinker-patch-cli-1.9.14.18.jar)

## **4.注意事项（必读）**

### 1)更新包的Proguard规则

如果app模块的build.gradle文件里设置了minifyEnabled和shrinkResources为true，则需注意默认的Proguard文件不能为proguard-android-optimize.txt，需修改为proguard-android.txt。因为R8的代码外联优化会破坏代码热更新机制。例如

```groovy
buildTypes {
    release {
        minifyEnabled true
        shrinkResources true
        proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
    }
}
```

### 2)更新包 minSDK<21时mutidex规则

**如果更新包工程的minSDK<21，则需要新增mutidex配置文件。**

在app目录下新建mutidex-config.pro文件，在该文件中新增以下内容。

```groovy
-keep class com.tencent.bugly.beta.tinker.**{*;}
-keep class com.bytedance.android.** {*;}
-keep class com.tencent.tinker.** {*;}
-keep class android.support.**{*;}
-keep class androidx.multidex.**{*;}
```

同时在app模块的build.gradle文件中新增对mutidex-config.pro文件的引用。

```groovy
defaultConfig {
    ...
    multiDexEnabled true
    multiDexKeepProguard file('multidex-config.pro')
}
```

最后需要把补丁包生成工具的配置文件tinker_config.xml中的allowLoaderInAnyDex和removeLoaderForAllDex改为false。

```xml
<issue id="property">
        ......
        
        <!-- use in minSDK>=21 -->
        <!-- when minSDK<21, please make allowLoaderInAnyDex and removeLoaderForAllDex all false-->
        <allowLoaderInAnyDex value="true" />
        <removeLoaderForAllDex value="true" />
</issue>
```

### 3)微端包和云端包数据通道使用

微端APP收到数据通道连接成功的回调onDataCHannelConnectSuccess，需要通过数据通道向云端APP发送一条数据，这样才能保证云端APP获取到微端APP发送时的端口号，云端APP才能正常发送数据到微端APP。
