## **1.接入流程**

### **1.1 集成步骤概述**

由于各模块之间存在依赖关系，您需要按照以下顺序完成集成的工作。

1.生成云端APP

在游戏原始包中接入云端SDK，添加登录/支付的逻辑，编译生成云端包，本地调试成功后，将云端APP通过微信对接群给到腾讯的工作人员，我们会把云端APP部署到我们的微端云游戏后台**，**待部署完成后，向工作人员获取部署的游戏ID，该游戏ID在微端APP集成中会使用。详细流程请参考【生成云端APP】

2.生成热更APP

在游戏原始包中接入热更新SDK，编译生成热更包，将生成的热更包保存。详细流程请参考【生成热更APP】。

3.生成微端APP

在微端APP示例工程的基础上进行二次开发，将生成的**微端包**保存，详细流程请参考【生成微端APP】。

4.生成补丁包

将保存的微端包和热更包通过命令行工具生成补丁包，请参考【生成补丁包】，将生成的补丁包通过微信对接群给到腾讯的工作人员，待工作人员上传完毕后，将微端包安装到手机上进行测试。



### **1.2 生成云端APP**

云端APP是在游戏原始包的基础上接入云端SDK，最终要部署运行到云游后台，提供和微端APP数据交换的能力（可以用来传输登录/支付数据）。



**详细步骤**：

第一步，使用Android Studio打开游戏原始包。

第二步，下载[SDK资源](https://recorder-10018504.cos.ap-shanghai.myqcloud.com/shaw/微端接入资源汇总/SDK资源汇总/SDK.zip)，将压缩包中的cloud-release.jar拷贝到app/libs下，打开app/build.gradle文件，添加云端SDK依赖。

```
dependencies {
    implementation files('libs/cloud-release.jar')
}
```

第三步，在集成云端SDK之后，需要使用云端SDK的能力在游戏原始包中新增端口监听能力，并将监听的端口号提供给微端APP，微端APP通过该端口向云端APP发送数据（登录/支付数据）。参考：[云端SDK使用文档](https://recorder-10018504.cos.ap-shanghai.myqcloud.com/shaw/project/junhai_v1.0.1_20211212/cloudSdk_javadoc.zip)

1）创建端口并监听微端APP发送的数据

```
   DatagramSocketThread.Listener listener = new Listener() {
        public void onReceive(byte[] buffer, int len) {
            // 从监听的端口接收到数据
            String dataFromRemote = new String(buffer, 0, len);
        }
        public void onException(Exception e) {
            // 数据接收或发送过程中出现异常
        }
    };
  
    socketThread = new DatagramSocketThread(listener, DEST_PORT);
    socketThread.start();
```

在onReceive中接收微端APP传递的已经经过微端处理的登录消息，例如登录token信息，微端APP获取到消息后进行处理。

2）发送数据给微端APP

在游戏需要登录的地方，通过以下接口将消息发送给微端APP，发送的数据可以自己定义。

```
socketThread.sendData("data".getBytes(StandardCharsets.UTF_8));
```

注意：发送数据必须在数据通道连接成功之后，发送数据必须在工作线程中。

3）数据通道建立完毕后，请参考【功能实现：登录/支付穿透】完成云端APP的改动。

第四步，本地调试，通过本地调试来验证端口是否能够正常通信。

新建一个测试APP，在测试APP中创建一个本地线程，同时打开测试APP和云端APP，在测试APP中使用下面代码给端口DEST_PORT发送消息，查看云端APP的Listener中是否能够正常收到该消息。

注意：需要提前打开云端APP，通过Android提供的分屏模式，打开测试APP和云端APP，在测试APP中发送测试消息，观察云端APP是否可以收到该消息。

```
// 创建一个本地socket
DatagramSocket socket = new DatagramSocket();
InetAddress address = InetAddress.getByName("localhost");
// 给UDP
DatagramPacket packet = new DatagramPacket("data ".getBytes(Charset.forName("UTF-8")), toastTest.length(), address, DEST_PORT);
Log.i(TAG, "send clientSendMsg");
socket.send(packet);
```

第五步，编译生成云端apk并部署到云端。

本地调试成功之后，clean工程，点击Android Studio的Gradle构建，使用assembleRelease编译生成云端apk，将该apk给到微信对接群中的工作人员，待游戏部署成功后向工作人员获取游戏ID。

​                 <img src="https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1MTEyNTg4NjQyOA_632895_lvfYeTlVuzy7HFME_1640073623?w=634&h=672" alt="img" style="zoom:50%;" />                         <img src="https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1MTEyNTg4NjQyOA_19167_YLu1h3SI67qgKUMU_1640073654?w=580&h=490" alt="img" style="zoom:50%;" />        

#  

### **1.3 生成热更APP**

热更APP不被安装运行，它的作用是和微端APP对比生成补丁包。生成热更APP的工程是由原始游戏工程集成热更新框架而成。下面详细介绍构建热更工程和热更APK的步骤：

第一步，修改构建脚本，引入热更新框架（插件和SDK）

打开游戏工程根目录下的build.gradle文件，添加远程依赖仓库jcenter和tinker-support热更新插件。

```
buildscript {
    repositories {
        mavenCentral() //必须添加这个仓库
        jcenter()
        google()
    }
    dependencies {
        classpath "com.android.tools.build:gradle:4.1.3"
        classpath "com.tencent.bugly:tinker-support:1.2.3" // 热更新插件
    }
}
```

下载热更新插件文件[tinker-support.gradle](https://recorder-10018504.cos.ap-shanghai.myqcloud.com/shaw/微端接入资源汇总/热更新配置文件/tinker-support.gradle)，将其拷贝到app目录下。打开app/build.gradle文件，引入热更新插件和相关依赖。

```
// 引入热更新插件脚本
apply from: 'tinker-support.gradle'
...
dependencies {
    implementation "com.tencent.tcr:tinker-wrapper:1.0.4.25" // 版本持续迭代中，请和开发人员获取最新版本
}
```

点击 ![img](https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1MTEyNTg4NjQyOA_744327_WckkRNRXjkG_7l57_1639984412?w=56&h=42) 按钮同步整个工程。



第二步，创建自定义Application。

如果游戏工程不存在自定义Application，请创建对应的Application

​                 <img src="https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1MTEyNTg4NjQyOA_696038_8LsD-YyGnBKSW6rD_1648176233?w=944&h=366" alt="img" style="zoom:50%;" />        

创建完成后将该Application填入到AndroidManifest.xml的application标签下。



第三步，修改混淆配置文件。

新建app/proguard-rules.pro文件新增以下内容。

```
# tinker-support插件
-dontwarn com.tencent.bugly.beta.tinker.**
-keep class com.tencent.bugly.beta.tinker.**{*;}
-keep class com.bytedance.android.** {*;}
# 避免找不到tinker相关类
-dontwarn com.tencent.tinker.**
-keep class com.tencent.tinker.** { *; }
# 避免影响升级功能，需要keep住support包的类
-keep class android.support.**{*;}
# 避免影响补丁包生成
-keep class androidx.multidex.**{*;}
```



第四步，生成热更APK。

clean工程，点击Android Studio的Gradle构建，使用assembleRelease编译生成构建物（热更apk、mapping文件和R文件），如下图。

​           <img src="https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1MTQxODI3NTY4MA_976490_64fnokpkZQz93GSJ_1641455749?w=742&h=842" alt="img" style="zoom: 33%;" />                         <img src="https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1MTQxODI3NTY4MA_503708_FsxH6up1-pKOYtJO_1641888411?w=590&h=530" alt="img" style="zoom: 50%;" />        

###  

### **1.4 生成微端APP**

微端APK是最终投放给用户的，用户下载安装运行到手机上，提供云试玩和热更新到完整游戏的能力。您可以下载[微端体验APK](https://recorder-10018504.cos.ap-shanghai.myqcloud.com/shaw/微端接入资源汇总/微端体验APK/app_1.0.1.50_release_20220322_1447.apk)进行体验。

微端APP的开发过程不需要从零开始，可以直接在[微端APP示例工程](https://recorder-10018504.cos.ap-shanghai.myqcloud.com/shaw/微端接入资源汇总/微端APP示例工程/TcrMicroAppForUnity2018Empty.zip)的基础上进行二次开发，该工程中已经接入了微端SDK和热更新SDK。 以下介绍详细步骤：

第一步，下载[微端APP示例工程](https://recorder-10018504.cos.ap-shanghai.myqcloud.com/shaw/微端接入资源汇总/微端APP示例工程/TcrMicroAppForUnity2018Empty.zip)，使用AndroidStudio打开。



第二步，修改构建脚本。打开app模块下的build.gradle文件，修改applicationId、minSdkVersion、targetSdkVersion与您的游戏工程一致。

​                 <img src="https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1MTEyNTg4NjQyOA_953937_EG0WZwd_j0uIa1CB_1647934163?w=1206&h=722" alt="img" style="zoom:50%;" />        

修改签名文件与您的热更工程一致。

​                 <img src="https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1MTEyNTg4NjQyOA_303564_6qsr-Udg4KeV_imt_1647934192?w=998&h=424" alt="img" style="zoom:50%;" />        

第三步，替换和修改AndroidManifest.xml文件。

将热更APP的AndroidManifest.xml文件拷贝到微端工程的对应目录下，替换同名文件。在该文件里声明的Application类和4大组件类，在微端工程里不存在的，会编译报错，可以使用IDE的Quick Fix功能创建对应的空类占位。



第四步，修改工程代码。

将GameApplication和MainActivity里的代码拷贝到第三步新AndroidManifest.xml文件里声明的Application类和主Activity类里。把原GameApplication和MainActivity类删掉。

修改Config类的GAME_ID、PATCH_URL、PORT变量

​                 ![img](https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1MTEyNTg4NjQyOA_129223_zDVSj1zhrQyOYX46_1647934244?w=1280&h=348.20457018498365)        

将【云端SDK接入指南】中云端apk部署之后生成的游戏ID填入到GAME_ID中，

在微信对接群中向工作人员获取补丁包的下载地址并填入到PATCH_URL中。

将【云端SDK接入指南】中云端APP开启的UDP端口填入到PORT中。



第五步（可选），修改游戏启动背景。

打开工程的res目录替换其中的game_background.jpg。

​                 <img src="https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1MTEyNTg4NjQyOA_367155_eJCwyWG8YH9dqaAE_1647934269?w=642&h=216" alt="img" style="zoom:50%;" />        





第六步（可选），如果您需要实现登录/支付穿透功能。

微端APP在onReceiveCloudGameMessage接口中收到云端APP发送的数据（例如，开始登录/支付）。将登录/支付的结果通过sendDataToCloudGame方法通知给云端APP。

​                 <img src="https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1MTEyNTg4NjQyOA_414279_eUXghvlVy2flme2R_1647933236?w=1226&h=556" alt="img" style="zoom:50%;" />        

*注意：数据发送必须要在onDataCHannelConnectSuccess之后进行。*



第七步，生成微端APK。

在微端APP的工程根目录下新建hotUpdate文件夹，

将3.3节热更工程里生成的构建物（xxx.apk和xxx-R.txt）拷贝到hotUpdate文件夹下。

修改tinker-support.gradle文件里的baseApkDir值为hotUpdate。

同时将baseApk的apk路径改为xxx.apk（刚拷贝到hotUpdate中的apk），

将baseApkResourceMapping的路径修改为xxx-R.txt。

注意：如果热更app发生修改，需要重新将热更app的构建物拷贝到hotUpdate文件夹下。

​                 <img src="https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1MTEyNTg4NjQyOA_471583_OCB5TLy0mRKARPXp_1647507482?w=1280&h=463.36328626444157" alt="img" style="zoom:50%;" />        

clean整个工程，然后点击Android Studio的Gradle构建，使用assembleRelease编译工程源码，生成微端apk。



### **1.5 生成补丁包**

第一步，安装java11环境，下载[补丁包生成工具](https://recorder-10018504.cos.ap-shanghai.myqcloud.com/shaw/微端接入资源汇总/PATCH生成工具/tools.zip)，解压文件，将其中的release.keystore替换为您的签名文件  ![img](https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1MTEyNTg4NjQyOA_685235_-VKlsghszTFIzKDn_1647934344?w=1052&h=310)        



第二步，修改配置文件。

打开tinker_config.xml文件，修改签名文件的密钥，                 ![img](https://docimg2.docs.qq.com/image/Qm7n65bcz4xvckeLy3q1Rw.png?w=1250&h=470)        



第三步，生成补丁包。

将前面生成的微端apk拷贝到tools目录下，重命名为old.apk。将前面生成的热更apk拷贝到tools目录下，重命名为new.apk。

在Terminal中进入到tools目录下，使用以下命令生成补丁包

```
java -jar tinker-patch-cli-1.9.14.18.jar -old old.apk -new new.apk -config tinker_config.xml -out patch
```



第四步，本地调试验证。

将生成的补丁包通过adb push到SD卡Download目录。

```
adb push patch/patch_signed.apk /storage/emulated/0/Download
```

打开本地调试模式（通过adb shell进入手机命令行，设置属性）

```
adb shell setprop log.tag.local_apply_patch true
```

安装微端apk到手机，运行之后会提示“选择本地补丁包“的弹窗，点击“选择文件”选取刚才push到sd卡的补丁文件，选择完毕后悬浮球显示更新中，更新完成弹出“重启弹窗”，点击“立即重启“按钮。

*注：本地调试时可以过滤log查看patch加载信息*，

```
adb logcat | grep Tinker
```



第五步，本地调试验证成功后，将补丁包通过微信对接群给到工作人员。



## **2.核心功能实现**

### **2.1功能实现：静默下载**

在云游戏微端试玩的基础上，我们还提供了在后台静默下载游戏包体（亦可按照客户需求，实现特异性的下载触发实现逻辑），以实现游戏投放的最终转化。

完成  **3.接入流程**，即已实现该功能。



### **2.2 功能实现：登录/支付穿透**

​                 ![img](https://docimg7.docs.qq.com/image/7QWjLfYrV-ERh6pR0lFN6g.png?w=1280&h=657.7628259041211)        

由于云端游戏限制，在云端实现登录/支付逻辑比较困难，所以需要将登录/支付的实现逻辑放到本地微端APP中，微端APP将处理结果通过数据通道传输给云端APP。

需要将游戏原始包中的原有登录/支付逻辑拆分到微端APP和云端APP中。

**特别注意**：

云端app和微端app开启数据通道连接成功之后（onDataChannelConnectSuccess发生回调），微端app必须先发一条消息，例如{"connect":"true"}，告知云端app本地数据通道已经连接成功，云端app收到这条消息之后，才可以向微端app传递业务数据。

#### **2.2.1微端APP改动**

1.实现登录/支付的具体逻辑

具体逻辑参照游戏原始包中的登录/支付代码。

2.通过微端SDK中提供的接口（sendDataToCloudGame）将处理的结果传输给云端APP。

*例如：在登录成功之后通过数据通道发送数据给云端APP*

```
String loginData = "{\"Access_Token\":\"edce2fbbf748df1d1d0ca3d6f\",\"OpenID\":1234567}";
sendDataToCloudGame(loginData));
```

#### **2.2.2云端APP改动**

云端APP需要在原始包的基础上将原有的登录/支付的实现逻辑从工程中移除，需要在发生登录/支付操作的地方，通过数据通道通知微端APP进行相应的登录/支付操作。

例如：在需要登录时通过数据通道通知微端APP（您可以自定义相关参数）

```
socketThread.sendData("login".getBytes(StandardCharsets.UTF_8));
```

注意：sendData不能在主线程中调用，会引起crash。

待微端APP处理完成后，接收微端APP通过数据通道传递的登录/支付结果，继续执行后续代码逻辑。

## **3.资源汇总**

[微端APP示例工程](https://recorder-10018504.cos.ap-shanghai.myqcloud.com/shaw/微端接入资源汇总/微端APP示例工程/TcrMicroAppForUnity2018Empty.zip)

[热更APP示例工程](https://recorder-10018504.cos.ap-shanghai.myqcloud.com/shaw/微端接入资源汇总/热更APP示例工程/AndroidUnity2018Empty.zip)

[云端APP示例工程](https://recorder-10018504.cos.ap-shanghai.myqcloud.com/shaw/微端接入资源汇总/云端APP示例工程/TcrMicroCloud.zip)

[云端SDK使用文档](https://recorder-10018504.cos.ap-shanghai.myqcloud.com/shaw/project/junhai_v1.0.1_20211212/cloudSdk_javadoc.zip)

[微端体验APK](https://recorder-10018504.cos.ap-shanghai.myqcloud.com/shaw/微端接入资源汇总/微端体验APK/app_1.0.1.50_release_20220322_1447.apk)

[SDK资源](https://recorder-10018504.cos.ap-shanghai.myqcloud.com/shaw/微端接入资源汇总/SDK资源汇总/SDK.zip)

[补丁包生成工具](https://recorder-10018504.cos.ap-shanghai.myqcloud.com/shaw/微端接入资源汇总/PATCH生成工具/tools.zip)

[热更新插件](https://recorder-10018504.cos.ap-shanghai.myqcloud.com/shaw/微端接入资源汇总/热更新配置文件/tinker-support.gradle)



## **4.注意事项（必读）**

### **热更APP的Proguard规则**

如果app模块的build.gradle文件里设置了minifyEnabled和shrinkResources为true，则需注意默认的Proguard文件不能为proguard-android-optimize.txt，需修改为proguard-android.txt。因为R8的代码外联优化会破坏代码热更新机制。例如

```
buildTypes {
    release {
        minifyEnabled true
        shrinkResources true
        proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
    }
}
```

### **热更APP minSDK<21时mutidex规则**

**如果热更工程的minSDK<21，则需要新增mutidex配置文件。**

在app目录下新建mutidex-config.pro文件，在该文件中新增以下内容。

```
-keep class com.tencent.bugly.beta.tinker.**{*;}
-keep class com.bytedance.android.** {*;}
-keep class com.tencent.tinker.** {*;}
-keep class android.support.**{*;}
-keep class androidx.multidex.**{*;}
```

同时在app模块的build.gradle文件中新增对mutidex-config.pro文件的引用。

```
defaultConfig {
    ...
    multiDexEnabled true
    multiDexKeepProguard file('multidex-config.pro')
}
```

最后需要把补丁包生成工具的配置文件tinker_config.xml中的allowLoaderInAnyDex和removeLoaderForAllDex改为false。 <img src="https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1MTEyNTg4NjQyOA_482731_oMY0POEytW-l-1Ys_1648025536?w=1068&h=252" alt="img" style="zoom:50%;" />        

### 微端APP和云端APP数据通道使用

微端APP收到数据通道连接成功的回调（*onDataCHannelConnectSuccess），*需要通过数据通道向云端APP发送一条数据，这样才能保证云端APP获取到微端APP发送时的端口号，云端APP才能正常发送数据到微端APP。



## **附录**

### 在配置文件中指定参与diff的so文件

首次接入时，微端app采用的sdk版本和热更app采用的版本是一致的，不需要进行该操作。

实际调试中，如果修改了微端app sdk的版本，但是热更app还是使用之前的版本（尽量减少热更app的修改）。

可以指定tinker_config.xml配置文件中需要进行热更新的so，来保证热更新之后sdk中的so仍然采用微端app中的版本。

第一步，打开热更app的apk文件，

![img](https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1MTEyNTg4NjQyOA_825971_XLKJOtEYRd8l_WzL_1648124848?w=1280&h=382.37600922722027)        



第二步，打开微端app的apk文件，                 ![img](https://wdoc-76491.picgzc.qpic.cn/MTY4ODg1MTEyNTg4NjQyOA_141847_9j9sBUjc2R2yTUL3_1648124930?w=1280&h=424.2696629213483)        



第三步，筛选出热更apk比微端apk多出来的so，libunity.so、libil2cpp.so、libmain.so，将这三个so添加到tinker_config.xml的lib标签中，

```
<issue id="lib">
        <!--what library in apk are expected to deal with tinkerPatch-->
        <!--it support * or ? pattern.-->
        <!--for library in assets, we would just recover them in the patch directory-->
        <!--you can get them in TinkerLoadResult with Tinker-->
        <pattern value="lib/*/libunity.so"/>
        <pattern value="lib/*/libil2cpp.so"/>
        <pattern value="lib/*/libmain.so"/>
    </issue>
```