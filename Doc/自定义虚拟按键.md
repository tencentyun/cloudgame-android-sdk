# 自定义虚拟按键

## 功能介绍

本文档主要介绍如何为您的游戏添加虚拟按键。

我们在虚拟按键的SDK中提供了便捷的编辑功能，您接入之后可以动态生成手自定义的虚拟按键。

同时你还可以通过虚拟手柄配置文件生成工具，生成默认的手柄布局。

## 接入步骤

1、将tcgui-gamepad-x.x.x.xx_xxxxxxxx_xxxx_release.aar拷贝到libs目录下。

2、在应用模块的`build.gradle`中加入：

```groovy
android {
      ......
      repositories {
        flatDir {
            dirs 'libs'
        }
      }
   }
   dependencies {
     ......
     // 自定义虚拟按键SDK
     implementation(name:"tcgui-gamepad-x.x.x.xx_xxxxxxxx_xxxx_release", ext:'aar')
   }
```

3、混淆配置

1）对java代码不做混淆

```java
-keep class com.tencent.tcggamepad.**{*;}
```

2）对资源文件不做混淆

```java
tools:keep="@drawable/tcg_*"
```

## 接口介绍

| 接口名称                                                     | 接口描述                 |
| ------------------------------------------------------------ | ------------------------ |
| GamepadManager.setEditListener(OnEditListener listener)      | 设置虚拟按键编辑事件监听 |
| GamepadManager.setInstructionListener(IInstructionListener listener) | 设置触发按钮事件的监听   |
| GamepadManager.setGamePadTouchDelegate(IGamepadTouchDelegate delegate) | 设置触摸事件的代理       |
| GamepadManager.showGamepad(String jsonCfg)                   | 显示虚拟手柄             |
| GamepadManager.editGamepad(String jsonCfg)                   | 编辑虚拟手柄             |
| GamepadManager.needConnected()                               | 判断是否为手柄按键       |

#### OnEditListener.onFinishEdit(boolean isChanged, String jsonCfg)

| 参数       | 类型    | 返回值 | 描述                   |
| ---------- | :------ | :----- | ---------------------- |
| isChanaged | boolean | 无     | 配置文件是否发生更改   |
| jsonCfg    | String  | 无     | 更改之后的配置文件内容 |

#### IInstructionListener.onSend(String instruction)

| 参数        | 类型   | 返回值 | 描述     |
| ----------- | :----- | :----- | -------- |
| instruction | String | 无     | 按键事件 |

#### IGamepadTouchDelegate.onTouch(View view, MotionEvent event)

| 参数  | 类型        | 描述         |
| ----- | :---------- | ------------ |
| view  | View        | 按键代理视图 |
| event | MotionEvent | 触摸事件     |

## 调用示例

```java
/**
 * 虚拟按键控制界面
 * 包含虚拟按键的展示、编辑功能
 */
public class GameControlView extends RelativeLayout {

    // 云端游SDK调用接口
    private IPcTcgSdk mSDK;
    // 虚拟按键管理类
    private GamepadManager mCustomGamePad;
    // 手柄配置文件
    private String mCustomGamePadCfg;
    private Context mContext;

    public GameControlView(Context context) {
        this(context, null);
    }

    public GameControlView(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public GameControlView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        mContext = context;
        initCustomGamePad();
    }

    private void initCustomGamePad() {
        mCustomGamePad = new GamepadManager(mContext);

        // 监听触发按钮事件的回调
        mCustomGamePad.setInstructionListener(new IInstructionListener() {
            @Override
            public void onSend(String instruction) {
                if (mSDK == null) {
                    return;
                }
                // 通过游戏SDK将指令发送出去
                mSDK.sendKmEvents(instruction);
            }
        });

        // 监听虚拟按键编辑事件的回调
        mCustomGamePad.setEditListener(new OnEditListener() {
            @Override
            public void onFinishEdit(boolean isChanged, String newCfg) {
                if (isChanged) {
                    // 保存编辑后的配置文件
                    mCustomGamePadCfg = newCfg;
                }
                mCustomGamePad.showGamepad(mCustomGamePadCfg);
            }
        });

        LayoutParams lp = new LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
                 ViewGroup.LayoutParams.MATCH_PARENT);
        addView(mCustomGamePad, lp);

        // 加载默认手柄配置文件
        mCustomGamePadCfg = FileUtil.readConfigFile(mContext, "tcg_default_xbox.cfg");
        mCustomGamePad.setVisibility(GONE);
    }

    // 显示编辑界面，编辑完成后回调到onFinishEdit
    public void editCustomGamePad(boolean enable) {
        if (enable) {
            mCustomGamePad.setVisibility(View.VISIBLE);
            mCustomGamePad.editGamepad(mCustomGamePadCfg);
        } else {
            mCustomGamePad.setVisibility(View.GONE);
        }
    }

    // 显示默认手柄
    public void showCustomGamePad(boolean enable) {
        showCustomGamePad(enable, null);
    }

    // 显示配置文件中的手柄
    public void showCustomGamePad(boolean enable, String conf) {
        if (enable) {
            if (!TextUtils.isEmpty(conf)) {
                mCustomGamePadCfg = conf;
            }
            mCustomGamePad.setVisibility(View.VISIBLE);
            mCustomGamePad.showGamepad(mCustomGamePadCfg);

            // 判断是否为手柄按键
            if (mCustomGamePad.needConnected()) {
              	// 通知云端启用手柄（需等SDK连接成功有画面之后再发送）
                // 云端游戏可能默认是使用键鼠，所以需要告知云端当前要使用手柄操作
                mSDK.sendGamePadConnected();
            }
        } else {
            mCustomGamePad.setVisibility(View.GONE);

            // 断开手柄连接
            if (mCustomGamePad.needConnected()) {
                // 通知云端卸载手柄
                mSDK.sendGamePadDisconnected();
            }
        }
    }

    // 设置端游SDK
    public void setSDK(IPcTcgSdk sdk) {
        mSDK = sdk;
    }

    // 设置touch事件的代理，将事件传递给鼠标视图
    public void setGamepadTouchDelegate(IGamepadTouchDelegate delegate) {
        mCustomGamePad.setGamePadTouchDelegate(delegate);
    }
}

```

## 接入后功能使用

您只需根据业务需求在合适的位置调用`GameControlView.editCustomGamePad(true)`开启虚拟按键的编辑界面。

### 支持的按键

支持的按键主要分为三类，鼠标及摇杆、键盘、手柄。

#### 鼠标及摇杆

1、鼠标按键（左、中、右、上滚、下滚）

2、摇杆（上下左右、WASD）

#### 键盘

1、实体键盘中常用的78个单机按键

#### 手柄

1、左、右摇杆键 

2、十字方向键

3、普通点击按键（A、B、X、Y、△、☐、×、○、Select、Start、LB、RB、L3、R3）

4、延时扳机键（LT、RT）【*点击时在短时间内连续发多次消息，消息的力度随时间逐增减*】

### 支持的编辑功能

- 动态添加/删除按键
- 动态调整按键位置、大小
- 通过辅助线定位按键
- 点击类按键支持修改名称(最多显示6个字符)

注：UI切图等资源暂不支持动态设置

## 配置文件生成

我们还提供了[自定义虚拟按键的配置](../TOOLS/vktool-release.apk)工具，您可以使用该工具生成的按键布局配置供SDK使用。同时您还可以在自己的代码中将`OnEditListener.onFinishEdit(boolean isChanged, String jsonCfg)`回调中的jsonCfg保存到本地，这个就是编辑完成之后的配置文件内容。

注：您不需要关心配置文件中的内容以及生成规则，您只需要导入和保存生成的配置文件供游戏使用。
